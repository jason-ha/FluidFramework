/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import type { ContainerExtensionStore } from "@fluidframework/container-definitions/internal";
import type { IContainerExperimental } from "@fluidframework/container-loader/internal";
import { assert } from "@fluidframework/core-utils/internal";
import type { IFluidContainer } from "@fluidframework/fluid-static";
import { isInternalFluidContainer } from "@fluidframework/fluid-static/internal";
import type { IContainerRuntimeBase } from "@fluidframework/runtime-definitions/internal";

import { acquireIndependentMapViaContainer } from "./independentStateManager.js";
import type { IndependentMap, IndependentMapAddress, IndependentMapSchema } from "./types.js";

function isContainerExtensionStore(
	manager: ContainerExtensionStore | IContainerRuntimeBase | IContainerExperimental,
): manager is ContainerExtensionStore {
	return (manager as ContainerExtensionStore).acquireExtension !== undefined;
}

/**
 * Acquire an IndependentMap from a Fluid Container
 * @param fluidContainer - Fluid Container to acquire the map from
 * @param id - unique identifier for the map
 * @param requestedContent -
 * @returns the IndependentMap
 *
 * @alpha
 */
export function acquireIndependentMap<TSchema extends IndependentMapSchema>(
	fluidContainer: IFluidContainer,
	id: IndependentMapAddress,
	requestedContent: TSchema,
): IndependentMap<TSchema> {
	assert(
		isInternalFluidContainer(fluidContainer),
		"IFluidContainer was not recognized. Only Containers generated by the Fluid Framework are supported.",
	);
	const innerContainer = fluidContainer.container;

	assert(
		isContainerExtensionStore(innerContainer),
		"Container does not support Independent State",
	);
	return acquireIndependentMapViaContainer(innerContainer, id, requestedContent);
}

/**
 * Acquire an IndependentMap from a Container Runtime
 *
 * @privateRemarks
 * Remove this utility for internal use - either state manager will exist under
 * a datastore or it was registered as extension with container runtime and no
 * need for this path trying to get from container using a datastore.
 *
 * @internal
 */
export function acquireIndependentMapInternal<TSchema extends IndependentMapSchema>(
	runtime: IContainerRuntimeBase,
	id: IndependentMapAddress,
	requestedContent: TSchema,
): IndependentMap<TSchema> {
	assert(isContainerExtensionStore(runtime), "Container does not support Independent State");
	return acquireIndependentMapViaContainer(runtime, id, requestedContent);
}
