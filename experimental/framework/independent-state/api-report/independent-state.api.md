## API Report File for "@fluid-experimental/independent-state"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AliasResult } from '@fluidframework/runtime-definitions';
import { FluidDataStoreRuntime } from '@fluidframework/datastore';
import type { IContainerRuntime } from '@fluidframework/container-runtime-definitions';
import type { IContainerRuntimeBase } from '@fluidframework/runtime-definitions';
import type { IEvent } from '@fluidframework/core-interfaces';
import type { IEventProvider } from '@fluidframework/core-interfaces';
import type { IFluidDataStoreRuntime } from '@fluidframework/datastore-definitions';
import type { NamedFluidDataStoreRegistryEntry } from '@fluidframework/runtime-definitions';

// @beta (undocumented)
export type ClientId = string;

// @beta (undocumented)
export function createIndependentMap<TSchema extends IndependentMapSchema>(runtime: IFluidEphemeralDataStoreRuntime, initialContent: TSchema): IndependentMap<TSchema>;

// @beta (undocumented)
type FullyReadonly<T> = {
    readonly [K in keyof T]: FullyReadonly<T[K]>;
};

// @beta
export type IFluidEphemeralDataStoreRuntime = Pick<IFluidDataStoreRuntime, "clientId" | "getAudience" | "off" | "on" | "submitSignal">;

// @beta (undocumented)
class IndependentDatastoreHandle<TKey, TValue extends ValueDirectoryOrState<any>> {
}

// @beta (undocumented)
export type IndependentMap<TSchema extends IndependentMapSchema> = IndependentMapEntries<TSchema> & IndependentMapMethods<TSchema>;

// @beta (undocumented)
export type IndependentMapEntries<TSchema extends IndependentMapSchema> = {
    readonly [Key in Exclude<keyof TSchema, keyof IndependentMapMethods<TSchema>>]: ReturnType<TSchema[Key]>["manager"] extends IndependentValue<infer TManager> ? TManager : never;
};

// @beta (undocumented)
export type IndependentMapEntry<TKey extends string, TValue extends ValueDirectoryOrState<any>, TManager = unknown> = ManagerFactory<TKey, TValue, TManager>;

// @alpha
export class IndependentMapFactory<TSchema extends IndependentMapSchema> {
    constructor(initialContent: TSchema, alias?: string, runtimeClass?: typeof FluidDataStoreRuntime);
    getMap(containerRuntime: IContainerRuntime): Promise<IndependentMap<TSchema>>;
    initializingFirstTime(containerRuntime: IContainerRuntimeBase): Promise<AliasResult>;
    // (undocumented)
    get registryEntry(): NamedFluidDataStoreRegistryEntry;
}

// @beta (undocumented)
export interface IndependentMapMethods<TSchema extends IndependentMapSchema> {
    // (undocumented)
    add<TKey extends string, TValue extends ValueDirectoryOrState<any>, TManager>(key: TKey, manager: ManagerFactory<TKey, TValue, TManager>): asserts this is IndependentMap<TSchema & Record<TKey, ManagerFactory<TKey, TValue, TManager>>>;
}

// @beta (undocumented)
export interface IndependentMapSchema {
    // (undocumented)
    [key: string]: IndependentMapEntry<typeof key, ValueDirectoryOrState<any>>;
}

// @beta
type IndependentValue<T> = T & IndependentValueBrand<T>;

// @beta
class IndependentValueBrand<T> {
}

declare namespace InternalTypes {
    export {
        ValueState,
        ValueDirectory,
        ValueDirectoryOrState,
        IndependentDatastoreHandle,
        IndependentValueBrand,
        IndependentValue,
        ManagerFactory
    }
}
export { InternalTypes }

declare namespace InternalUtilityTypes {
    export {
        NonSymbolWithOptionalPropertyOf,
        NonSymbolWithRequiredPropertyOf,
        NonSymbolWithDefinedNonFunctionPropertyOf,
        NonSymbolWithUndefinedNonFunctionPropertyOf,
        FullyReadonly
    }
}
export { InternalUtilityTypes }

// @beta
export type JsonDeserialized<T, TReplaced = never> = boolean extends (T extends never ? true : false) ? JsonDeserializedTypeWith<TReplaced> : unknown extends T ? JsonDeserializedTypeWith<TReplaced> : T extends null | boolean | number | string | TReplaced ? T : Extract<T, Function> extends never ? T extends object ? T extends (infer E)[] ? JsonDeserialized<E, TReplaced>[] : /* property bag => */ {
    [K in NonSymbolWithDefinedNonFunctionPropertyOf<T>]: JsonDeserialized<T[K], TReplaced>;
} & {
    [K in NonSymbolWithUndefinedNonFunctionPropertyOf<T>]?: JsonDeserialized<T[K], TReplaced>;
} : never : never;

// @beta
export type JsonDeserializedTypeWith<T> = null | boolean | number | string | T | {
    [key: string | number]: JsonDeserializedTypeWith<T>;
} | JsonDeserializedTypeWith<T>[];

// @beta
export type JsonEncodable<T, TReplaced = never> = boolean extends (T extends never ? true : false) ? JsonEncodableTypeWith<TReplaced> : unknown extends T ? JsonEncodableTypeWith<TReplaced> : T extends null | boolean | number | string | TReplaced ? T : Extract<T, Function> extends never ? T extends object ? T extends (infer U)[] ? JsonEncodable<U, TReplaced>[] : /* property bag => */ {
    [K in NonSymbolWithRequiredPropertyOf<T>]-?: undefined extends T[K] ? "error-required-property-may-not-allow-undefined-value" : JsonEncodable<T[K], TReplaced>;
} & {
    [K in NonSymbolWithOptionalPropertyOf<T>]?: JsonEncodable<T[K], TReplaced | undefined>;
} & {
    [K in keyof T & symbol]: never;
} : never : never;

// @beta
export type JsonEncodableTypeWith<T> = null | boolean | number | string | T | {
    [key: string | number]: JsonEncodableTypeWith<T>;
} | JsonEncodableTypeWith<T>[];

// @beta (undocumented)
export function Latest<T extends object, Key extends string>(initialValue: JsonEncodable<T> & JsonDeserialized<T> & object): ManagerFactory<Key, ValueState<T>, LatestValueManager<T>>;

// @beta (undocumented)
export interface LatestValueClientData<T> extends LatestValueData<T> {
    // (undocumented)
    clientId: ClientId;
}

// @beta (undocumented)
export interface LatestValueData<T> {
    // (undocumented)
    metadata: LatestValueMetadata;
    // (undocumented)
    value: FullyReadonly<JsonDeserialized<T>>;
}

// @beta (undocumented)
export interface LatestValueManager<T> extends IEventProvider<LatestValueManagerEvents<T>> {
    // (undocumented)
    clients(): ClientId[];
    // (undocumented)
    clientValue(clientId: ClientId): LatestValueData<T>;
    // (undocumented)
    clientValues(): IterableIterator<LatestValueClientData<T>>;
    // (undocumented)
    get local(): FullyReadonly<JsonDeserialized<T>>;
    set local(value: JsonEncodable<T> & JsonDeserialized<T>);
}

// @beta (undocumented)
export interface LatestValueManagerEvents<T> extends IEvent {
    // @eventProperty
    (event: "update", listener: (update: LatestValueClientData<T>) => void): void;
}

// @beta (undocumented)
export interface LatestValueMetadata {
    // (undocumented)
    revision: number;
    // (undocumented)
    timestamp: number;
}

// @beta
type ManagerFactory<TKey extends string, TValue extends ValueDirectoryOrState<any>, TManager> = (key: TKey, datastoreHandle: IndependentDatastoreHandle<TKey, TValue>) => {
    value: TValue;
    manager: IndependentValue<TManager>;
};

// @beta (undocumented)
type NonSymbolWithDefinedNonFunctionPropertyOf<T extends object> = Exclude<{
    [K in keyof T]: undefined extends T[K] ? never : T[K] extends Function ? never : K;
}[keyof T], undefined | symbol>;

// @beta (undocumented)
type NonSymbolWithOptionalPropertyOf<T extends object> = Exclude<{
    [K in keyof T]: T extends Record<K, T[K]> ? never : K;
}[keyof T], undefined | symbol>;

// @beta (undocumented)
type NonSymbolWithRequiredPropertyOf<T extends object> = Exclude<{
    [K in keyof T]: T extends Record<K, T[K]> ? K : never;
}[keyof T], undefined | symbol>;

// @beta (undocumented)
type NonSymbolWithUndefinedNonFunctionPropertyOf<T extends object> = Exclude<{
    [K in keyof T]: undefined extends T[K] ? (T[K] extends Function ? never : K) : never;
}[keyof T], undefined | symbol>;

// @beta (undocumented)
interface ValueDirectory<T> {
    // (undocumented)
    items: {
        [name: string | number]: ValueDirectoryOrState<T>;
    };
    // (undocumented)
    rev: number;
}

// @beta (undocumented)
type ValueDirectoryOrState<T> = ValueState<T> | ValueDirectory<T>;

// @beta (undocumented)
interface ValueState<TValue> {
    // (undocumented)
    rev: number;
    // (undocumented)
    timestamp: number;
    // (undocumented)
    value: JsonDeserialized<TValue>;
}

// (No @packageDocumentation comment for this package)

```
