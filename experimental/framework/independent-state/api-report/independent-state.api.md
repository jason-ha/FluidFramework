## API Report File for "@fluid-experimental/independent-state"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { AliasResult } from '@fluidframework/runtime-definitions/internal';
import { FluidDataStoreRuntime } from '@fluidframework/datastore/internal';
import type { IContainerRuntime } from '@fluidframework/container-runtime-definitions/internal';
import type { IContainerRuntimeBase } from '@fluidframework/runtime-definitions/internal';
import type { IFluidDataStoreRuntime } from '@fluidframework/datastore-definitions/internal';
import type { NamedFluidDataStoreRegistryEntry } from '@fluidframework/runtime-definitions/internal';

// @beta
export type ClientId = string;

// @internal
export function createIndependentMap<TSchema extends IndependentMapSchema>(runtime: IFluidEphemeralDataStoreRuntime, initialContent: TSchema): IndependentMap<TSchema>;

// @beta
export type Events<E> = {
    [P in (string | symbol) & keyof E as IsEvent<E[P]> extends true ? P : never]: E[P];
};

// @beta
type FlattenIntersection<T> = T extends Record<string | number | symbol, unknown> ? {
    [K in keyof T]: T[K];
} : T;

// @beta
type FullyReadonly<T> = {
    readonly [K in keyof T]: FullyReadonly<T[K]>;
};

// @internal
export type IFluidEphemeralDataStoreRuntime = Pick<IFluidDataStoreRuntime, "clientId" | "getAudience" | "off" | "on" | "submitSignal">;

// @beta (undocumented)
class IndependentDatastoreHandle<TKey, TValue extends ValueDirectoryOrState<any>> {
}

// @beta
export type IndependentMap<TSchema extends IndependentMapSchema> = IndependentMapEntries<TSchema> & IndependentMapMethods<TSchema>;

// @beta
export type IndependentMapEntries<TSchema extends IndependentMapSchema> = {
    /**
    * Registered `Value Manager`s
    */
    readonly [Key in Exclude<keyof TSchema, keyof IndependentMapMethods<TSchema>>]: ReturnType<TSchema[Key]>["manager"] extends IndependentValue<infer TManager> ? TManager : never;
};

// @beta
export type IndependentMapEntry<TKey extends string, TValue extends ValueDirectoryOrState<unknown>, TManager = unknown> = ManagerFactory<TKey, TValue, TManager>;

// @alpha
export class IndependentMapFactory<TSchema extends IndependentMapSchema> {
    constructor(initialContent: TSchema, alias?: string, runtimeClass?: typeof FluidDataStoreRuntime);
    getMap(containerRuntime: IContainerRuntime): Promise<IndependentMap<TSchema>>;
    initializingFirstTime(containerRuntime: IContainerRuntimeBase): Promise<AliasResult>;
    // (undocumented)
    get registryEntry(): NamedFluidDataStoreRegistryEntry;
}

// @beta
export interface IndependentMapMethods<TSchema extends IndependentMapSchema> {
    add<TKey extends string, TValue extends ValueDirectoryOrState<any>, TManager>(key: TKey, manager: ManagerFactory<TKey, TValue, TManager>): asserts this is IndependentMap<TSchema & Record<TKey, ManagerFactory<TKey, TValue, TManager>>>;
}

// @beta
export interface IndependentMapSchema {
    // (undocumented)
    [key: string]: IndependentMapEntry<typeof key, ValueDirectoryOrState<any>>;
}

// @beta
type IndependentValue<T> = T & IndependentValueBrand<T>;

// @beta
class IndependentValueBrand<T> {
}

declare namespace InternalTypes {
    export {
        ValueStateMetadata,
        ValueOptionalState,
        ValueRequiredState,
        ValueDirectory,
        ValueDirectoryOrState,
        IndependentDatastoreHandle,
        IndependentValueBrand,
        IndependentValue,
        ManagerFactory,
        NotificationType
    }
}
export { InternalTypes }

declare namespace InternalUtilityTypes {
    export {
        NonSymbolWithOptionalPropertyOf,
        NonSymbolWithRequiredPropertyOf,
        NonSymbolWithDefinedNonFunctionPropertyOf,
        NonSymbolWithPossiblyUndefinedNonFunctionPropertyOf,
        JsonForArrayItem,
        IsEnumLike,
        IsExactlyObject,
        FlattenIntersection,
        FullyReadonly,
        IsNotificationEvent,
        NotificationEvents,
        JsonDeserializedParameters,
        JsonEncodableParameters
    }
}
export { InternalUtilityTypes }

// @beta
type IsEnumLike<T extends object> = T extends readonly (infer _)[] ? false : T extends {
    readonly [i: number]: string;
    readonly [p: string]: number | string;
} ? true extends {
    [K in keyof T]: T[K] extends never ? true : never;
}[keyof T] ? false : true : false;

// @beta
export type IsEvent<Event> = Event extends (...args: any[]) => any ? true : false;

// @beta
type IsExactlyObject<T extends object> = object extends Required<T> ? false extends T ? false : true : false;

// @beta
type IsNotificationEvent<Event> = Event extends (...args: infer P) => void ? P extends JsonDeserialized<P> & JsonEncodable<P> ? JsonDeserialized<P> & JsonEncodable<P> extends P ? true : false : false : false;

// @beta
export interface ISubscribable<E extends Events<E>> {
    on<K extends keyof Events<E>>(eventName: K, listener: E[K]): () => void;
}

// @beta
export type JsonDeserialized<T, TReplaced = never> = boolean extends (T extends never ? true : false) ? JsonTypeWith<TReplaced> : unknown extends T ? JsonTypeWith<TReplaced> : T extends null | boolean | number | string | TReplaced ? T : Extract<T, Function> extends never ? T extends object ? T extends readonly (infer _)[] ? {
    [K in keyof T]: JsonForArrayItem<T[K], TReplaced, JsonDeserialized<T[K], TReplaced>>;
} : IsExactlyObject<T> extends true ? JsonTypeWith<TReplaced> : IsEnumLike<T> extends true ? T : FlattenIntersection<{
    [K in NonSymbolWithDefinedNonFunctionPropertyOf<T>]: JsonDeserialized<T[K], TReplaced>;
} & {
    [K in NonSymbolWithPossiblyUndefinedNonFunctionPropertyOf<T>]?: JsonDeserialized<T[K], TReplaced>;
}> : never : never;

// @beta
type JsonDeserializedParameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? JsonDeserialized<P> : never;

// @beta
export type JsonEncodable<T, TReplaced = never> = boolean extends (T extends never ? true : false) ? JsonTypeWith<TReplaced> : unknown extends T ? JsonTypeWith<TReplaced> : T extends null | boolean | number | string | TReplaced ? T : Extract<T, Function> extends never ? T extends object ? T extends readonly (infer _)[] ? {
    [K in keyof T]: JsonForArrayItem<T[K], TReplaced, JsonEncodable<T[K], TReplaced>>;
} : IsExactlyObject<T> extends true ? JsonTypeWith<TReplaced> : IsEnumLike<T> extends true ? T : FlattenIntersection<{
    [K in NonSymbolWithRequiredPropertyOf<T>]-?: undefined extends T[K] ? "error-required-property-may-not-allow-undefined-value" : JsonEncodable<T[K], TReplaced>;
} & {
    [K in NonSymbolWithOptionalPropertyOf<T>]?: JsonEncodable<T[K], TReplaced | undefined>;
} & {
    [K in keyof T & symbol]: never;
}> : never : never;

// @beta
type JsonEncodableParameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? JsonEncodable<P> : never;

// @beta
type JsonForArrayItem<T, TReplaced, TBlessed> = boolean extends (T extends never ? true : false) ? TBlessed : unknown extends T ? TBlessed : T extends null | boolean | number | string | TReplaced ? T : undefined extends T ? "error-array-or-tuple-may-not-allow-undefined-value-consider-null" : TBlessed;

// @beta
export type JsonTypeWith<T> = null | boolean | number | string | T | {
    [key: string | number]: JsonTypeWith<T>;
} | JsonTypeWith<T>[];

// @beta
export function Latest<T extends object, Key extends string>(initialValue: JsonEncodable<T> & JsonDeserialized<T> & object, controls?: LatestValueControls): ManagerFactory<Key, ValueRequiredState<T>, LatestValueManager<T>>;

// @beta
export function LatestMap<T extends object, RegistrationKey extends string, Keys extends string | number = string | number>(initialValues?: {
    [K in Keys]: JsonEncodable<T> & JsonDeserialized<T>;
}, controls?: LatestValueControls): ManagerFactory<RegistrationKey, MapValueState<T>, LatestMapValueManager<T, Keys>>;

// @beta
export interface LatestMapItemRemovedClientData<K extends string | number> {
    // (undocumented)
    clientId: ClientId;
    // (undocumented)
    key: K;
    // (undocumented)
    metadata: LatestValueMetadata;
}

// @beta
export interface LatestMapItemValueClientData<T, K extends string | number> extends LatestValueClientData<T> {
    // (undocumented)
    key: K;
}

// @beta
export interface LatestMapValueClientData<SpecificClientId extends ClientId, T, Keys extends string | number> {
    clientId: SpecificClientId;
    // (undocumented)
    items: ReadonlyMap<Keys, LatestValueData<T>>;
}

// @beta
export interface LatestMapValueManager<T, Keys extends string | number = string | number> {
    clients(): ClientId[];
    clientValue<SpecificClientId extends ClientId>(clientId: SpecificClientId): LatestMapValueClientData<SpecificClientId, T, Keys>;
    clientValues(): IterableIterator<LatestMapValueClientData<ClientId, T, Keys>>;
    readonly controls: LatestValueControls;
    readonly events: ISubscribable<LatestMapValueManagerEvents<T, Keys>>;
    readonly local: ValueMap<Keys, T>;
}

// @beta (undocumented)
export interface LatestMapValueManagerEvents<T, K extends string | number> {
    // @eventProperty
    itemRemoved: (removedItem: LatestMapItemRemovedClientData<K>) => void;
    // @eventProperty
    itemUpdated: (updatedItem: LatestMapItemValueClientData<T, K>) => void;
    // @eventProperty
    updated: (updates: LatestMapValueClientData<ClientId, T, K>) => void;
}

// @beta
export interface LatestValueClientData<T> extends LatestValueData<T> {
    // (undocumented)
    clientId: ClientId;
}

// @beta
export interface LatestValueControls {
    allowableUpdateLatency: number;
    forcedRefreshInterval: number;
}

// @beta
export interface LatestValueData<T> {
    // (undocumented)
    metadata: LatestValueMetadata;
    // (undocumented)
    value: FullyReadonly<JsonDeserialized<T>>;
}

// @beta
export interface LatestValueManager<T> {
    clients(): ClientId[];
    clientValue(clientId: ClientId): LatestValueData<T>;
    clientValues(): IterableIterator<LatestValueClientData<T>>;
    readonly controls: LatestValueControls;
    readonly events: ISubscribable<LatestValueManagerEvents<T>>;
    get local(): FullyReadonly<JsonDeserialized<T>>;
    set local(value: JsonEncodable<T> & JsonDeserialized<T>);
}

// @beta (undocumented)
export interface LatestValueManagerEvents<T> {
    // @eventProperty
    updated: (update: LatestValueClientData<T>) => void;
}

// @beta
export interface LatestValueMetadata {
    revision: number;
    timestamp: number;
}

// @beta
type ManagerFactory<TKey extends string, TValue extends ValueDirectoryOrState<any>, TManager> = (key: TKey, datastoreHandle: IndependentDatastoreHandle<TKey, TValue>) => {
    value: TValue;
    manager: IndependentValue<TManager>;
};

// @beta (undocumented)
export interface MapValueState<T> {
    // (undocumented)
    items: {
        [name: string | number]: ValueOptionalState<T>;
    };
    // (undocumented)
    rev: number;
}

// @beta
type NonSymbolWithDefinedNonFunctionPropertyOf<T extends object> = Exclude<{
    [K in keyof T]: undefined extends T[K] ? never : T[K] extends Function ? never : K;
}[keyof T], undefined | symbol>;

// @beta
type NonSymbolWithOptionalPropertyOf<T extends object> = Exclude<{
    [K in keyof T]: T extends Record<K, T[K]> ? never : K;
}[keyof T], undefined | symbol>;

// @beta
type NonSymbolWithPossiblyUndefinedNonFunctionPropertyOf<T extends object> = Exclude<{
    [K in keyof T]: undefined extends T[K] ? T[K] extends Function ? never : Exclude<T[K], undefined> extends never ? never : K : never;
}[keyof T], undefined | symbol>;

// @beta
type NonSymbolWithRequiredPropertyOf<T extends object> = Exclude<{
    [K in keyof T]: T extends Record<K, T[K]> ? K : never;
}[keyof T], undefined | symbol>;

// @beta
export interface NotificationEmitter<E extends NotificationEvents<E>> {
    broadcast<K extends string & keyof NotificationEvents<E>>(notificationName: K, ...args: Parameters<E[K]>): void;
    unicast<K extends string & keyof NotificationEvents<E>>(notificationName: K, targetClientId: ClientId, ...args: Parameters<E[K]>): void;
}

// @beta
type NotificationEvents<E> = {
    [P in string & keyof E as IsNotificationEvent<E[P]> extends true ? P : never]: E[P];
};

// @beta
export function Notifications<T extends NotificationEvents<T>, Key extends string>(initialSubscriptions: NotificationSubscriptions<T>): ManagerFactory<Key, ValueRequiredState<NotificationType>, NotificationsManager<T>>;

// @beta
export interface NotificationsManager<T extends NotificationEvents<T>> {
    readonly emit: NotificationEmitter<T>;
    readonly events: ISubscribable<NotificationsManagerEvents>;
    readonly notifications: NotificationSubscribable<T>;
}

// @beta (undocumented)
export interface NotificationsManagerEvents {
    // @eventProperty
    unattendedNotification: (name: string, sender: ClientId, ...content: unknown[]) => void;
}

// @beta
export interface NotificationSubscribable<E extends NotificationEvents<E>> {
    on<K extends keyof NotificationEvents<E>>(notificationName: K, listener: (sender: ClientId, ...args: JsonDeserializedParameters<E[K]>) => void): () => void;
}

// @beta
export type NotificationSubscriptions<E extends NotificationEvents<E>> = {
    [K in string & keyof NotificationEvents<E>]: (sender: ClientId, ...args: JsonEncodableParameters<E[K]>) => void;
};

// @beta (undocumented)
interface NotificationType {
    // (undocumented)
    args: (JsonEncodable<unknown> & JsonDeserialized<unknown>)[];
    // (undocumented)
    name: string;
}

// @beta (undocumented)
interface ValueDirectory<T> {
    // (undocumented)
    items: {
        [name: string | number]: ValueOptionalState<T> | ValueDirectory<T>;
    };
    // (undocumented)
    rev: number;
}

// @beta (undocumented)
type ValueDirectoryOrState<T> = ValueRequiredState<T> | ValueDirectory<T>;

// @beta
export interface ValueMap<K extends string | number, V> {
    clear(): void;
    // (undocumented)
    delete(key: K): boolean;
    forEach(callbackfn: (value: FullyReadonly<JsonDeserialized<V>>, key: K, map: ValueMap<K, V>) => void, thisArg?: unknown): void;
    get(key: K): FullyReadonly<JsonDeserialized<V>> | undefined;
    // (undocumented)
    has(key: K): boolean;
    keys(): IterableIterator<K>;
    set(key: K, value: JsonEncodable<V> & JsonDeserialized<V>): this;
    // (undocumented)
    readonly size: number;
}

// @beta (undocumented)
interface ValueOptionalState<TValue> extends ValueStateMetadata {
    // (undocumented)
    value?: JsonDeserialized<TValue>;
}

// @beta (undocumented)
interface ValueRequiredState<TValue> extends ValueStateMetadata {
    // (undocumented)
    value: JsonDeserialized<TValue>;
}

// @beta (undocumented)
interface ValueStateMetadata {
    // (undocumented)
    rev: number;
    // (undocumented)
    timestamp: number;
}

// (No @packageDocumentation comment for this package)

```
