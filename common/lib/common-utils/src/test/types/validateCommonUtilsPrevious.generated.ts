/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */
import type * as old from "@fluidframework/common-utils-previous";
import type * as current from "../../index";


// See 'build-tools/src/type-test-generator/compatibility.ts' for more information.
type TypeOnly<T> = T extends number
	? number
	: T extends string
	? string
	: T extends boolean | bigint | symbol
	? T
	: {
			[P in keyof T]: TypeOnly<T[P]>;
	  };

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BaseTelemetryNullLogger": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_BaseTelemetryNullLogger():
    TypeOnly<old.BaseTelemetryNullLogger>;
declare function use_current_ClassDeclaration_BaseTelemetryNullLogger(
    use: TypeOnly<current.BaseTelemetryNullLogger>);
use_current_ClassDeclaration_BaseTelemetryNullLogger(
    get_old_ClassDeclaration_BaseTelemetryNullLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BaseTelemetryNullLogger": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_BaseTelemetryNullLogger():
    TypeOnly<current.BaseTelemetryNullLogger>;
declare function use_old_ClassDeclaration_BaseTelemetryNullLogger(
    use: TypeOnly<old.BaseTelemetryNullLogger>);
use_old_ClassDeclaration_BaseTelemetryNullLogger(
    get_current_ClassDeclaration_BaseTelemetryNullLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedClassDeclaration_Buffer": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedClassDeclaration_Buffer": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Deferred": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Deferred():
    TypeOnly<old.Deferred<any>>;
declare function use_current_ClassDeclaration_Deferred(
    use: TypeOnly<current.Deferred<any>>);
use_current_ClassDeclaration_Deferred(
    get_old_ClassDeclaration_Deferred());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Deferred": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Deferred():
    TypeOnly<current.Deferred<any>>;
declare function use_old_ClassDeclaration_Deferred(
    use: TypeOnly<old.Deferred<any>>);
use_old_ClassDeclaration_Deferred(
    get_current_ClassDeclaration_Deferred());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedTypeAliasDeclaration_EventEmitterEventType": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedTypeAliasDeclaration_EventEmitterEventType": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedClassDeclaration_EventForwarder": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedClassDeclaration_EventForwarder": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Heap": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Heap():
    TypeOnly<old.Heap<any>>;
declare function use_current_ClassDeclaration_Heap(
    use: TypeOnly<current.Heap<any>>);
use_current_ClassDeclaration_Heap(
    get_old_ClassDeclaration_Heap());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Heap": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Heap():
    TypeOnly<current.Heap<any>>;
declare function use_old_ClassDeclaration_Heap(
    use: TypeOnly<old.Heap<any>>);
use_old_ClassDeclaration_Heap(
    get_current_ClassDeclaration_Heap());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IComparer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IComparer():
    TypeOnly<old.IComparer<any>>;
declare function use_current_InterfaceDeclaration_IComparer(
    use: TypeOnly<current.IComparer<any>>);
use_current_InterfaceDeclaration_IComparer(
    get_old_InterfaceDeclaration_IComparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IComparer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IComparer():
    TypeOnly<current.IComparer<any>>;
declare function use_old_InterfaceDeclaration_IComparer(
    use: TypeOnly<old.IComparer<any>>);
use_old_InterfaceDeclaration_IComparer(
    get_current_InterfaceDeclaration_IComparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IHeapNode": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IHeapNode():
    TypeOnly<old.IHeapNode<any>>;
declare function use_current_InterfaceDeclaration_IHeapNode(
    use: TypeOnly<current.IHeapNode<any>>);
use_current_InterfaceDeclaration_IHeapNode(
    get_old_InterfaceDeclaration_IHeapNode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IHeapNode": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IHeapNode():
    TypeOnly<current.IHeapNode<any>>;
declare function use_old_InterfaceDeclaration_IHeapNode(
    use: TypeOnly<old.IHeapNode<any>>);
use_old_InterfaceDeclaration_IHeapNode(
    get_current_InterfaceDeclaration_IHeapNode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPromiseTimer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPromiseTimer():
    TypeOnly<old.IPromiseTimer>;
declare function use_current_InterfaceDeclaration_IPromiseTimer(
    use: TypeOnly<current.IPromiseTimer>);
use_current_InterfaceDeclaration_IPromiseTimer(
    get_old_InterfaceDeclaration_IPromiseTimer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPromiseTimer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPromiseTimer():
    TypeOnly<current.IPromiseTimer>;
declare function use_old_InterfaceDeclaration_IPromiseTimer(
    use: TypeOnly<old.IPromiseTimer>);
use_old_InterfaceDeclaration_IPromiseTimer(
    get_current_InterfaceDeclaration_IPromiseTimer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPromiseTimerResult": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPromiseTimerResult():
    TypeOnly<old.IPromiseTimerResult>;
declare function use_current_InterfaceDeclaration_IPromiseTimerResult(
    use: TypeOnly<current.IPromiseTimerResult>);
use_current_InterfaceDeclaration_IPromiseTimerResult(
    get_old_InterfaceDeclaration_IPromiseTimerResult());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPromiseTimerResult": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPromiseTimerResult():
    TypeOnly<current.IPromiseTimerResult>;
declare function use_old_InterfaceDeclaration_IPromiseTimerResult(
    use: TypeOnly<old.IPromiseTimerResult>);
use_old_InterfaceDeclaration_IPromiseTimerResult(
    get_current_InterfaceDeclaration_IPromiseTimerResult());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRange": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRange():
    TypeOnly<old.IRange>;
declare function use_current_InterfaceDeclaration_IRange(
    use: TypeOnly<current.IRange>);
use_current_InterfaceDeclaration_IRange(
    get_old_InterfaceDeclaration_IRange());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRange": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRange():
    TypeOnly<current.IRange>;
declare function use_old_InterfaceDeclaration_IRange(
    use: TypeOnly<old.IRange>);
use_old_InterfaceDeclaration_IRange(
    get_current_InterfaceDeclaration_IRange());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRangeTrackerSnapshot": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRangeTrackerSnapshot():
    TypeOnly<old.IRangeTrackerSnapshot>;
declare function use_current_InterfaceDeclaration_IRangeTrackerSnapshot(
    use: TypeOnly<current.IRangeTrackerSnapshot>);
use_current_InterfaceDeclaration_IRangeTrackerSnapshot(
    get_old_InterfaceDeclaration_IRangeTrackerSnapshot());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRangeTrackerSnapshot": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRangeTrackerSnapshot():
    TypeOnly<current.IRangeTrackerSnapshot>;
declare function use_old_InterfaceDeclaration_IRangeTrackerSnapshot(
    use: TypeOnly<old.IRangeTrackerSnapshot>);
use_old_InterfaceDeclaration_IRangeTrackerSnapshot(
    get_current_InterfaceDeclaration_IRangeTrackerSnapshot());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITimer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITimer():
    TypeOnly<old.ITimer>;
declare function use_current_InterfaceDeclaration_ITimer(
    use: TypeOnly<current.ITimer>);
use_current_InterfaceDeclaration_ITimer(
    get_old_InterfaceDeclaration_ITimer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITimer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITimer():
    TypeOnly<current.ITimer>;
declare function use_old_InterfaceDeclaration_ITimer(
    use: TypeOnly<old.ITimer>);
use_old_InterfaceDeclaration_ITimer(
    get_current_InterfaceDeclaration_ITimer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedInterfaceDeclaration_ITraceEvent": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedInterfaceDeclaration_ITraceEvent": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedVariableDeclaration_IsoBuffer": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedVariableDeclaration_IsoBuffer": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedTypeAliasDeclaration_IsoBuffer": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedTypeAliasDeclaration_IsoBuffer": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedTypeAliasDeclaration_IsomorphicPerformance": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedTypeAliasDeclaration_IsomorphicPerformance": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Lazy": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Lazy():
    TypeOnly<old.Lazy<any>>;
declare function use_current_ClassDeclaration_Lazy(
    use: TypeOnly<current.Lazy<any>>);
use_current_ClassDeclaration_Lazy(
    get_old_ClassDeclaration_Lazy());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Lazy": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Lazy():
    TypeOnly<current.Lazy<any>>;
declare function use_old_ClassDeclaration_Lazy(
    use: TypeOnly<old.Lazy<any>>);
use_old_ClassDeclaration_Lazy(
    get_current_ClassDeclaration_Lazy());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_LazyPromise": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_LazyPromise():
    TypeOnly<old.LazyPromise<any>>;
declare function use_current_ClassDeclaration_LazyPromise(
    use: TypeOnly<current.LazyPromise<any>>);
use_current_ClassDeclaration_LazyPromise(
    get_old_ClassDeclaration_LazyPromise());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_LazyPromise": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_LazyPromise():
    TypeOnly<current.LazyPromise<any>>;
declare function use_old_ClassDeclaration_LazyPromise(
    use: TypeOnly<old.LazyPromise<any>>);
use_old_ClassDeclaration_LazyPromise(
    get_current_ClassDeclaration_LazyPromise());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_NumberComparer": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_NumberComparer():
    TypeOnly<typeof old.NumberComparer>;
declare function use_current_VariableDeclaration_NumberComparer(
    use: TypeOnly<typeof current.NumberComparer>);
use_current_VariableDeclaration_NumberComparer(
    get_old_VariableDeclaration_NumberComparer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_NumberComparer": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_NumberComparer():
    TypeOnly<typeof current.NumberComparer>;
declare function use_old_VariableDeclaration_NumberComparer(
    use: TypeOnly<typeof old.NumberComparer>);
use_old_VariableDeclaration_NumberComparer(
    get_current_VariableDeclaration_NumberComparer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PromiseCache": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_PromiseCache():
    TypeOnly<old.PromiseCache<any,any>>;
declare function use_current_ClassDeclaration_PromiseCache(
    use: TypeOnly<current.PromiseCache<any,any>>);
use_current_ClassDeclaration_PromiseCache(
    get_old_ClassDeclaration_PromiseCache());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PromiseCache": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_PromiseCache():
    TypeOnly<current.PromiseCache<any,any>>;
declare function use_old_ClassDeclaration_PromiseCache(
    use: TypeOnly<old.PromiseCache<any,any>>);
use_old_ClassDeclaration_PromiseCache(
    get_current_ClassDeclaration_PromiseCache());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_PromiseCacheExpiry": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_PromiseCacheExpiry():
    TypeOnly<old.PromiseCacheExpiry>;
declare function use_current_TypeAliasDeclaration_PromiseCacheExpiry(
    use: TypeOnly<current.PromiseCacheExpiry>);
use_current_TypeAliasDeclaration_PromiseCacheExpiry(
    get_old_TypeAliasDeclaration_PromiseCacheExpiry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_PromiseCacheExpiry": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_PromiseCacheExpiry():
    TypeOnly<current.PromiseCacheExpiry>;
declare function use_old_TypeAliasDeclaration_PromiseCacheExpiry(
    use: TypeOnly<old.PromiseCacheExpiry>);
use_old_TypeAliasDeclaration_PromiseCacheExpiry(
    get_current_TypeAliasDeclaration_PromiseCacheExpiry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_PromiseCacheOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_PromiseCacheOptions():
    TypeOnly<old.PromiseCacheOptions>;
declare function use_current_InterfaceDeclaration_PromiseCacheOptions(
    use: TypeOnly<current.PromiseCacheOptions>);
use_current_InterfaceDeclaration_PromiseCacheOptions(
    get_old_InterfaceDeclaration_PromiseCacheOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_PromiseCacheOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_PromiseCacheOptions():
    TypeOnly<current.PromiseCacheOptions>;
declare function use_old_InterfaceDeclaration_PromiseCacheOptions(
    use: TypeOnly<old.PromiseCacheOptions>);
use_old_InterfaceDeclaration_PromiseCacheOptions(
    get_current_InterfaceDeclaration_PromiseCacheOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PromiseTimer": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_PromiseTimer():
    TypeOnly<old.PromiseTimer>;
declare function use_current_ClassDeclaration_PromiseTimer(
    use: TypeOnly<current.PromiseTimer>);
use_current_ClassDeclaration_PromiseTimer(
    get_old_ClassDeclaration_PromiseTimer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PromiseTimer": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_PromiseTimer():
    TypeOnly<current.PromiseTimer>;
declare function use_old_ClassDeclaration_PromiseTimer(
    use: TypeOnly<old.PromiseTimer>);
use_old_ClassDeclaration_PromiseTimer(
    get_current_ClassDeclaration_PromiseTimer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RangeTracker": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_RangeTracker():
    TypeOnly<old.RangeTracker>;
declare function use_current_ClassDeclaration_RangeTracker(
    use: TypeOnly<current.RangeTracker>);
use_current_ClassDeclaration_RangeTracker(
    get_old_ClassDeclaration_RangeTracker());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RangeTracker": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_RangeTracker():
    TypeOnly<current.RangeTracker>;
declare function use_old_ClassDeclaration_RangeTracker(
    use: TypeOnly<old.RangeTracker>);
use_old_ClassDeclaration_RangeTracker(
    get_current_ClassDeclaration_RangeTracker());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RateLimiter": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_RateLimiter():
    TypeOnly<old.RateLimiter>;
declare function use_current_ClassDeclaration_RateLimiter(
    use: TypeOnly<current.RateLimiter>);
use_current_ClassDeclaration_RateLimiter(
    get_old_ClassDeclaration_RateLimiter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RateLimiter": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_RateLimiter():
    TypeOnly<current.RateLimiter>;
declare function use_old_ClassDeclaration_RateLimiter(
    use: TypeOnly<old.RateLimiter>);
use_old_ClassDeclaration_RateLimiter(
    get_current_ClassDeclaration_RateLimiter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TelemetryNullLogger": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_TelemetryNullLogger():
    TypeOnly<old.TelemetryNullLogger>;
declare function use_current_ClassDeclaration_TelemetryNullLogger(
    use: TypeOnly<current.TelemetryNullLogger>);
use_current_ClassDeclaration_TelemetryNullLogger(
    get_old_ClassDeclaration_TelemetryNullLogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TelemetryNullLogger": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_TelemetryNullLogger():
    TypeOnly<current.TelemetryNullLogger>;
declare function use_old_ClassDeclaration_TelemetryNullLogger(
    use: TypeOnly<old.TelemetryNullLogger>);
use_old_ClassDeclaration_TelemetryNullLogger(
    get_current_ClassDeclaration_TelemetryNullLogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Timer": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Timer():
    TypeOnly<old.Timer>;
declare function use_current_ClassDeclaration_Timer(
    use: TypeOnly<current.Timer>);
use_current_ClassDeclaration_Timer(
    get_old_ClassDeclaration_Timer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Timer": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Timer():
    TypeOnly<current.Timer>;
declare function use_old_ClassDeclaration_Timer(
    use: TypeOnly<old.Timer>);
use_old_ClassDeclaration_Timer(
    get_current_ClassDeclaration_Timer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedClassDeclaration_Trace": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedClassDeclaration_Trace": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedClassDeclaration_TypedEventEmitter": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedClassDeclaration_TypedEventEmitter": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedTypeAliasDeclaration_TypedEventTransform": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedTypeAliasDeclaration_TypedEventTransform": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedFunctionDeclaration_Uint8ArrayToArrayBuffer": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedFunctionDeclaration_Uint8ArrayToArrayBuffer": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedFunctionDeclaration_Uint8ArrayToString": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedFunctionDeclaration_Uint8ArrayToString": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_assert": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_assert():
    TypeOnly<typeof old.assert>;
declare function use_current_FunctionDeclaration_assert(
    use: TypeOnly<typeof current.assert>);
use_current_FunctionDeclaration_assert(
    get_old_FunctionDeclaration_assert());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_assert": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_assert():
    TypeOnly<typeof current.assert>;
declare function use_old_FunctionDeclaration_assert(
    use: TypeOnly<typeof old.assert>);
use_old_FunctionDeclaration_assert(
    get_current_FunctionDeclaration_assert());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedVariableDeclaration_bufferToString": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedVariableDeclaration_bufferToString": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_delay": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_delay():
    TypeOnly<typeof old.delay>;
declare function use_current_VariableDeclaration_delay(
    use: TypeOnly<typeof current.delay>);
use_current_VariableDeclaration_delay(
    get_old_VariableDeclaration_delay());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_delay": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_delay():
    TypeOnly<typeof current.delay>;
declare function use_old_VariableDeclaration_delay(
    use: TypeOnly<typeof old.delay>);
use_old_VariableDeclaration_delay(
    get_current_VariableDeclaration_delay());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_doIfNotDisposed": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_doIfNotDisposed():
    TypeOnly<typeof old.doIfNotDisposed>;
declare function use_current_FunctionDeclaration_doIfNotDisposed(
    use: TypeOnly<typeof current.doIfNotDisposed>);
use_current_FunctionDeclaration_doIfNotDisposed(
    get_old_FunctionDeclaration_doIfNotDisposed());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_doIfNotDisposed": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_doIfNotDisposed():
    TypeOnly<typeof current.doIfNotDisposed>;
declare function use_old_FunctionDeclaration_doIfNotDisposed(
    use: TypeOnly<typeof old.doIfNotDisposed>);
use_old_FunctionDeclaration_doIfNotDisposed(
    get_current_FunctionDeclaration_doIfNotDisposed());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedVariableDeclaration_fromBase64ToUtf8": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedVariableDeclaration_fromBase64ToUtf8": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedVariableDeclaration_fromUtf8ToBase64": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedVariableDeclaration_fromUtf8ToBase64": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedFunctionDeclaration_gitHashFile": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedFunctionDeclaration_gitHashFile": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedFunctionDeclaration_hashFile": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedFunctionDeclaration_hashFile": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedVariableDeclaration_performance": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedVariableDeclaration_performance": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_safelyParseJSON": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_safelyParseJSON():
    TypeOnly<typeof old.safelyParseJSON>;
declare function use_current_FunctionDeclaration_safelyParseJSON(
    use: TypeOnly<typeof current.safelyParseJSON>);
use_current_FunctionDeclaration_safelyParseJSON(
    get_old_FunctionDeclaration_safelyParseJSON());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_safelyParseJSON": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_safelyParseJSON():
    TypeOnly<typeof current.safelyParseJSON>;
declare function use_old_FunctionDeclaration_safelyParseJSON(
    use: TypeOnly<typeof old.safelyParseJSON>);
use_old_FunctionDeclaration_safelyParseJSON(
    get_current_FunctionDeclaration_safelyParseJSON());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_setLongTimeout": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_setLongTimeout():
    TypeOnly<typeof old.setLongTimeout>;
declare function use_current_FunctionDeclaration_setLongTimeout(
    use: TypeOnly<typeof current.setLongTimeout>);
use_current_FunctionDeclaration_setLongTimeout(
    get_old_FunctionDeclaration_setLongTimeout());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_setLongTimeout": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_setLongTimeout():
    TypeOnly<typeof current.setLongTimeout>;
declare function use_old_FunctionDeclaration_setLongTimeout(
    use: TypeOnly<typeof old.setLongTimeout>);
use_old_FunctionDeclaration_setLongTimeout(
    get_current_FunctionDeclaration_setLongTimeout());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedFunctionDeclaration_stringToBuffer": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedFunctionDeclaration_stringToBuffer": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedVariableDeclaration_toUtf8": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedVariableDeclaration_toUtf8": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_unreachableCase": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_unreachableCase():
    TypeOnly<typeof old.unreachableCase>;
declare function use_current_FunctionDeclaration_unreachableCase(
    use: TypeOnly<typeof current.unreachableCase>);
use_current_FunctionDeclaration_unreachableCase(
    get_old_FunctionDeclaration_unreachableCase());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_unreachableCase": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_unreachableCase():
    TypeOnly<typeof current.unreachableCase>;
declare function use_old_FunctionDeclaration_unreachableCase(
    use: TypeOnly<typeof old.unreachableCase>);
use_old_FunctionDeclaration_unreachableCase(
    get_current_FunctionDeclaration_unreachableCase());
