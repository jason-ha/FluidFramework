## Beta API Report File for "@fluidframework/core-interfaces"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type ConfigTypes = string | number | boolean | number[] | string[] | boolean[] | undefined;

// @public @sealed
export abstract class ErasedType<out Name = unknown> {
    static [Symbol.hasInstance](value: never): value is never;
    protected abstract brand(dummy: never): Name;
}

// @public
export type ExtendEventProvider<TBaseEvent extends IEvent, TBase extends IEventProvider<TBaseEvent>, TEvent extends TBaseEvent> = Omit<Omit<Omit<TBase, "on">, "once">, "off"> & IEventProvider<TBaseEvent> & IEventProvider<TEvent>;

// @public
export const fluidHandleSymbol: unique symbol;

// @public
export type FluidObject<T = unknown> = {
    [P in FluidObjectProviderKeys<T>]?: T[P];
};

// @public
export type FluidObjectKeys<T> = keyof FluidObject<T>;

// @public
export type FluidObjectProviderKeys<T, TProp extends keyof T = keyof T> = string extends TProp ? never : number extends TProp ? never : TProp extends keyof Required<T>[TProp] ? Required<T>[TProp] extends Required<Required<T>[TProp]>[TProp] ? TProp : never : never;

// @public
export interface IConfigProviderBase {
    getRawConfig(name: string): ConfigTypes;
}

// @public @sealed
export interface IDisposable {
    dispose(error?: Error): void;
    readonly disposed: boolean;
}

// @public
export interface IErrorBase extends Partial<Error> {
    readonly errorType: string;
    getTelemetryProperties?(): ITelemetryBaseProperties;
    readonly message: string;
    readonly name?: string;
    readonly stack?: string;
}

// @public
export interface IErrorEvent extends IEvent {
    // @eventProperty
    (event: "error", listener: (message: any) => void): any;
}

// @public
export interface IEvent {
    // @eventProperty
    (event: string, listener: (...args: any[]) => void): any;
}

// @public @sealed
export interface IEventProvider<TEvent extends IEvent> {
    readonly off: IEventTransformer<this, TEvent>;
    readonly on: IEventTransformer<this, TEvent>;
    readonly once: IEventTransformer<this, TEvent>;
}

// @public
export type IEventThisPlaceHolder = {
    thisPlaceHolder: "thisPlaceHolder";
};

// @public
export type IEventTransformer<TThis, TEvent extends IEvent> = TEvent extends {
    (event: infer E0, listener: (...args: infer A0) => void): any;
    (event: infer E1, listener: (...args: infer A1) => void): any;
    (event: infer E2, listener: (...args: infer A2) => void): any;
    (event: infer E3, listener: (...args: infer A3) => void): any;
    (event: infer E4, listener: (...args: infer A4) => void): any;
    (event: infer E5, listener: (...args: infer A5) => void): any;
    (event: infer E6, listener: (...args: infer A6) => void): any;
    (event: infer E7, listener: (...args: infer A7) => void): any;
    (event: infer E8, listener: (...args: infer A8) => void): any;
    (event: infer E9, listener: (...args: infer A9) => void): any;
    (event: infer E10, listener: (...args: infer A10) => void): any;
    (event: infer E11, listener: (...args: infer A11) => void): any;
    (event: infer E12, listener: (...args: infer A12) => void): any;
    (event: infer E13, listener: (...args: infer A13) => void): any;
    (event: infer E14, listener: (...args: infer A14) => void): any;
    (event: string, listener: (...args: any[]) => void): any;
} ? TransformedEvent<TThis, E0, A0> & TransformedEvent<TThis, E1, A1> & TransformedEvent<TThis, E2, A2> & TransformedEvent<TThis, E3, A3> & TransformedEvent<TThis, E4, A4> & TransformedEvent<TThis, E5, A5> & TransformedEvent<TThis, E6, A6> & TransformedEvent<TThis, E7, A7> & TransformedEvent<TThis, E8, A8> & TransformedEvent<TThis, E9, A9> & TransformedEvent<TThis, E10, A10> & TransformedEvent<TThis, E11, A11> & TransformedEvent<TThis, E12, A12> & TransformedEvent<TThis, E13, A13> & TransformedEvent<TThis, E14, A14> : TEvent extends {
    (event: infer E0, listener: (...args: infer A0) => void): any;
    (event: infer E1, listener: (...args: infer A1) => void): any;
    (event: infer E2, listener: (...args: infer A2) => void): any;
    (event: infer E3, listener: (...args: infer A3) => void): any;
    (event: infer E4, listener: (...args: infer A4) => void): any;
    (event: infer E5, listener: (...args: infer A5) => void): any;
    (event: infer E6, listener: (...args: infer A6) => void): any;
    (event: infer E7, listener: (...args: infer A7) => void): any;
    (event: infer E8, listener: (...args: infer A8) => void): any;
    (event: infer E9, listener: (...args: infer A9) => void): any;
    (event: infer E10, listener: (...args: infer A10) => void): any;
    (event: infer E11, listener: (...args: infer A11) => void): any;
    (event: infer E12, listener: (...args: infer A12) => void): any;
    (event: infer E13, listener: (...args: infer A13) => void): any;
    (event: string, listener: (...args: any[]) => void): any;
} ? TransformedEvent<TThis, E0, A0> & TransformedEvent<TThis, E1, A1> & TransformedEvent<TThis, E2, A2> & TransformedEvent<TThis, E3, A3> & TransformedEvent<TThis, E4, A4> & TransformedEvent<TThis, E5, A5> & TransformedEvent<TThis, E6, A6> & TransformedEvent<TThis, E7, A7> & TransformedEvent<TThis, E8, A8> & TransformedEvent<TThis, E9, A9> & TransformedEvent<TThis, E10, A10> & TransformedEvent<TThis, E11, A11> & TransformedEvent<TThis, E12, A12> & TransformedEvent<TThis, E13, A13> : TEvent extends {
    (event: infer E0, listener: (...args: infer A0) => void): any;
    (event: infer E1, listener: (...args: infer A1) => void): any;
    (event: infer E2, listener: (...args: infer A2) => void): any;
    (event: infer E3, listener: (...args: infer A3) => void): any;
    (event: infer E4, listener: (...args: infer A4) => void): any;
    (event: infer E5, listener: (...args: infer A5) => void): any;
    (event: infer E6, listener: (...args: infer A6) => void): any;
    (event: infer E7, listener: (...args: infer A7) => void): any;
    (event: infer E8, listener: (...args: infer A8) => void): any;
    (event: infer E9, listener: (...args: infer A9) => void): any;
    (event: infer E10, listener: (...args: infer A10) => void): any;
    (event: infer E11, listener: (...args: infer A11) => void): any;
    (event: infer E12, listener: (...args: infer A12) => void): any;
    (event: string, listener: (...args: any[]) => void): any;
} ? TransformedEvent<TThis, E0, A0> & TransformedEvent<TThis, E1, A1> & TransformedEvent<TThis, E2, A2> & TransformedEvent<TThis, E3, A3> & TransformedEvent<TThis, E4, A4> & TransformedEvent<TThis, E5, A5> & TransformedEvent<TThis, E6, A6> & TransformedEvent<TThis, E7, A7> & TransformedEvent<TThis, E8, A8> & TransformedEvent<TThis, E9, A9> & TransformedEvent<TThis, E10, A10> & TransformedEvent<TThis, E11, A11> & TransformedEvent<TThis, E12, A12> : TEvent extends {
    (event: infer E0, listener: (...args: infer A0) => void): any;
    (event: infer E1, listener: (...args: infer A1) => void): any;
    (event: infer E2, listener: (...args: infer A2) => void): any;
    (event: infer E3, listener: (...args: infer A3) => void): any;
    (event: infer E4, listener: (...args: infer A4) => void): any;
    (event: infer E5, listener: (...args: infer A5) => void): any;
    (event: infer E6, listener: (...args: infer A6) => void): any;
    (event: infer E7, listener: (...args: infer A7) => void): any;
    (event: infer E8, listener: (...args: infer A8) => void): any;
    (event: infer E9, listener: (...args: infer A9) => void): any;
    (event: infer E10, listener: (...args: infer A10) => void): any;
    (event: infer E11, listener: (...args: infer A11) => void): any;
    (event: string, listener: (...args: any[]) => void): any;
} ? TransformedEvent<TThis, E0, A0> & TransformedEvent<TThis, E1, A1> & TransformedEvent<TThis, E2, A2> & TransformedEvent<TThis, E3, A3> & TransformedEvent<TThis, E4, A4> & TransformedEvent<TThis, E5, A5> & TransformedEvent<TThis, E6, A6> & TransformedEvent<TThis, E7, A7> & TransformedEvent<TThis, E8, A8> & TransformedEvent<TThis, E9, A9> & TransformedEvent<TThis, E10, A10> & TransformedEvent<TThis, E11, A11> : TEvent extends {
    (event: infer E0, listener: (...args: infer A0) => void): any;
    (event: infer E1, listener: (...args: infer A1) => void): any;
    (event: infer E2, listener: (...args: infer A2) => void): any;
    (event: infer E3, listener: (...args: infer A3) => void): any;
    (event: infer E4, listener: (...args: infer A4) => void): any;
    (event: infer E5, listener: (...args: infer A5) => void): any;
    (event: infer E6, listener: (...args: infer A6) => void): any;
    (event: infer E7, listener: (...args: infer A7) => void): any;
    (event: infer E8, listener: (...args: infer A8) => void): any;
    (event: infer E9, listener: (...args: infer A9) => void): any;
    (event: infer E10, listener: (...args: infer A10) => void): any;
    (event: string, listener: (...args: any[]) => void): any;
} ? TransformedEvent<TThis, E0, A0> & TransformedEvent<TThis, E1, A1> & TransformedEvent<TThis, E2, A2> & TransformedEvent<TThis, E3, A3> & TransformedEvent<TThis, E4, A4> & TransformedEvent<TThis, E5, A5> & TransformedEvent<TThis, E6, A6> & TransformedEvent<TThis, E7, A7> & TransformedEvent<TThis, E8, A8> & TransformedEvent<TThis, E9, A9> & TransformedEvent<TThis, E10, A10> : TEvent extends {
    (event: infer E0, listener: (...args: infer A0) => void): any;
    (event: infer E1, listener: (...args: infer A1) => void): any;
    (event: infer E2, listener: (...args: infer A2) => void): any;
    (event: infer E3, listener: (...args: infer A3) => void): any;
    (event: infer E4, listener: (...args: infer A4) => void): any;
    (event: infer E5, listener: (...args: infer A5) => void): any;
    (event: infer E6, listener: (...args: infer A6) => void): any;
    (event: infer E7, listener: (...args: infer A7) => void): any;
    (event: infer E8, listener: (...args: infer A8) => void): any;
    (event: infer E9, listener: (...args: infer A9) => void): any;
    (event: string, listener: (...args: any[]) => void): any;
} ? TransformedEvent<TThis, E0, A0> & TransformedEvent<TThis, E1, A1> & TransformedEvent<TThis, E2, A2> & TransformedEvent<TThis, E3, A3> & TransformedEvent<TThis, E4, A4> & TransformedEvent<TThis, E5, A5> & TransformedEvent<TThis, E6, A6> & TransformedEvent<TThis, E7, A7> & TransformedEvent<TThis, E8, A8> & TransformedEvent<TThis, E9, A9> : TEvent extends {
    (event: infer E0, listener: (...args: infer A0) => void): any;
    (event: infer E1, listener: (...args: infer A1) => void): any;
    (event: infer E2, listener: (...args: infer A2) => void): any;
    (event: infer E3, listener: (...args: infer A3) => void): any;
    (event: infer E4, listener: (...args: infer A4) => void): any;
    (event: infer E5, listener: (...args: infer A5) => void): any;
    (event: infer E6, listener: (...args: infer A6) => void): any;
    (event: infer E7, listener: (...args: infer A7) => void): any;
    (event: infer E8, listener: (...args: infer A8) => void): any;
    (event: string, listener: (...args: any[]) => void): any;
} ? TransformedEvent<TThis, E0, A0> & TransformedEvent<TThis, E1, A1> & TransformedEvent<TThis, E2, A2> & TransformedEvent<TThis, E3, A3> & TransformedEvent<TThis, E4, A4> & TransformedEvent<TThis, E5, A5> & TransformedEvent<TThis, E6, A6> & TransformedEvent<TThis, E7, A7> & TransformedEvent<TThis, E8, A8> : TEvent extends {
    (event: infer E0, listener: (...args: infer A0) => void): any;
    (event: infer E1, listener: (...args: infer A1) => void): any;
    (event: infer E2, listener: (...args: infer A2) => void): any;
    (event: infer E3, listener: (...args: infer A3) => void): any;
    (event: infer E4, listener: (...args: infer A4) => void): any;
    (event: infer E5, listener: (...args: infer A5) => void): any;
    (event: infer E6, listener: (...args: infer A6) => void): any;
    (event: infer E7, listener: (...args: infer A7) => void): any;
    (event: string, listener: (...args: any[]) => void): any;
} ? TransformedEvent<TThis, E0, A0> & TransformedEvent<TThis, E1, A1> & TransformedEvent<TThis, E2, A2> & TransformedEvent<TThis, E3, A3> & TransformedEvent<TThis, E4, A4> & TransformedEvent<TThis, E5, A5> & TransformedEvent<TThis, E6, A6> & TransformedEvent<TThis, E7, A7> : TEvent extends {
    (event: infer E0, listener: (...args: infer A0) => void): any;
    (event: infer E1, listener: (...args: infer A1) => void): any;
    (event: infer E2, listener: (...args: infer A2) => void): any;
    (event: infer E3, listener: (...args: infer A3) => void): any;
    (event: infer E4, listener: (...args: infer A4) => void): any;
    (event: infer E5, listener: (...args: infer A5) => void): any;
    (event: infer E6, listener: (...args: infer A6) => void): any;
    (event: string, listener: (...args: any[]) => void): any;
} ? TransformedEvent<TThis, E0, A0> & TransformedEvent<TThis, E1, A1> & TransformedEvent<TThis, E2, A2> & TransformedEvent<TThis, E3, A3> & TransformedEvent<TThis, E4, A4> & TransformedEvent<TThis, E5, A5> & TransformedEvent<TThis, E6, A6> : TEvent extends {
    (event: infer E0, listener: (...args: infer A0) => void): any;
    (event: infer E1, listener: (...args: infer A1) => void): any;
    (event: infer E2, listener: (...args: infer A2) => void): any;
    (event: infer E3, listener: (...args: infer A3) => void): any;
    (event: infer E4, listener: (...args: infer A4) => void): any;
    (event: infer E5, listener: (...args: infer A5) => void): any;
    (event: string, listener: (...args: any[]) => void): any;
} ? TransformedEvent<TThis, E0, A0> & TransformedEvent<TThis, E1, A1> & TransformedEvent<TThis, E2, A2> & TransformedEvent<TThis, E3, A3> & TransformedEvent<TThis, E4, A4> & TransformedEvent<TThis, E5, A5> : TEvent extends {
    (event: infer E0, listener: (...args: infer A0) => void): any;
    (event: infer E1, listener: (...args: infer A1) => void): any;
    (event: infer E2, listener: (...args: infer A2) => void): any;
    (event: infer E3, listener: (...args: infer A3) => void): any;
    (event: infer E4, listener: (...args: infer A4) => void): any;
    (event: string, listener: (...args: any[]) => void): any;
} ? TransformedEvent<TThis, E0, A0> & TransformedEvent<TThis, E1, A1> & TransformedEvent<TThis, E2, A2> & TransformedEvent<TThis, E3, A3> & TransformedEvent<TThis, E4, A4> : TEvent extends {
    (event: infer E0, listener: (...args: infer A0) => void): any;
    (event: infer E1, listener: (...args: infer A1) => void): any;
    (event: infer E2, listener: (...args: infer A2) => void): any;
    (event: infer E3, listener: (...args: infer A3) => void): any;
    (event: string, listener: (...args: any[]) => void): any;
} ? TransformedEvent<TThis, E0, A0> & TransformedEvent<TThis, E1, A1> & TransformedEvent<TThis, E2, A2> & TransformedEvent<TThis, E3, A3> : TEvent extends {
    (event: infer E0, listener: (...args: infer A0) => void): any;
    (event: infer E1, listener: (...args: infer A1) => void): any;
    (event: infer E2, listener: (...args: infer A2) => void): any;
    (event: string, listener: (...args: any[]) => void): any;
} ? TransformedEvent<TThis, E0, A0> & TransformedEvent<TThis, E1, A1> & TransformedEvent<TThis, E2, A2> : TEvent extends {
    (event: infer E0, listener: (...args: infer A0) => void): any;
    (event: infer E1, listener: (...args: infer A1) => void): any;
    (event: string, listener: (...args: any[]) => void): any;
} ? TransformedEvent<TThis, E0, A0> & TransformedEvent<TThis, E1, A1> : TEvent extends {
    (event: infer E0, listener: (...args: infer A0) => void): any;
    (event: string, listener: (...args: any[]) => void): any;
} ? TransformedEvent<TThis, E0, A0> : TransformedEvent<TThis, string, any[]>;

// @public (undocumented)
export const IFluidHandle = "IFluidHandle";

// @public @sealed
export interface IFluidHandle<out T = unknown> {
    readonly [fluidHandleSymbol]: IFluidHandleErased<T>;
    get(): Promise<T>;
    readonly isAttached: boolean;
}

// @public @sealed
export interface IFluidHandleErased<T> extends ErasedType<readonly ["IFluidHandle", T]> {
}

// @public (undocumented)
export const IFluidLoadable: keyof IProvideFluidLoadable;

// @public @sealed
export interface IFluidLoadable extends IProvideFluidLoadable {
    // (undocumented)
    readonly handle: IFluidHandle;
}

// @beta
export namespace InternalUtilityTypes {
    export type ExcludeExactly<T, U> = IfSameType<T, U, never, T>;
    export type ExtractFunctionFromIntersection<T extends object> = (T extends new (...args: infer A) => infer R ? new (...args: A) => R : unknown) & (T extends (...args: infer A) => infer R ? (...args: A) => R : unknown) extends infer Functional ? {
        classification: unknown extends Functional ? "no Function" : Functional extends Required<T> ? "exactly Function" : "Function and more";
        function: Functional;
    } : never;
    export interface FilterControls {
        AllowExactly: unknown;
        AllowExtensionOf: unknown;
    }
    export type FilterPreservingFunction<Original extends object, Filtered> = ExtractFunctionFromIntersection<Original> extends {
        classification: infer TClassification;
        function: infer TFunction;
    } ? TClassification extends "exactly Function" ? TFunction : TFunction & Filtered : never;
    export type FlattenIntersection<T extends Record<string | number | symbol, unknown>> = T extends Record<string | number | symbol, unknown> ? {
        [K in keyof T]: T[K];
    } : T;
    export type HasNonPublicProperties<T, Controls extends FilterControls> = ReplaceAllowancesAndRecursionWithNever<T, Controls> extends T ? false : true;
    export type IfExactTypeInTuple<T, Tuple extends unknown[], IfMatch = unknown, IfNoMatch = never> = Tuple extends [infer First, ...infer Rest] ? IfSameType<T, First, IfMatch, IfExactTypeInTuple<T, Rest, IfMatch, IfNoMatch>> : IfNoMatch;
    export type IfExactTypeInUnion<T, Union, IfMatch = unknown, IfNoMatch = never> = IfSameType<T, never, IfSameType<Union, never, IfMatch, IfNoMatch>, IfSameType<T, Extract<Union, T>, IfMatch, IfNoMatch>>;
    export type IfSameType<X, Y, IfSame = unknown, IfDifferent = never> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? IfSame : IfDifferent;
    export type IsEnumLike<T extends object> = T extends readonly (infer _)[] ? false : T extends Function ? false : T extends {
        readonly [i: number]: string;
        readonly [p: string]: number | string;
        readonly [s: symbol]: never;
    } ? true extends {
        [K in keyof T]: T[K] extends never ? true : never;
    }[keyof T] ? false : true : false;
    export type IsExactlyObject<T extends object> = IsSameType<T, object>;
    export type IsSameType<X, Y> = IfSameType<X, Y, true, false>;
    export type JsonDeserializedFilter<T, Controls extends FilterControls, RecurseLimit extends RecursionLimit, TAncestorTypes = T> = boolean extends (T extends never ? true : false) ? JsonTypeWith<Controls["AllowExactly"] | Controls["AllowExtensionOf"]> : unknown extends T ? JsonTypeWith<Controls["AllowExactly"] | Controls["AllowExtensionOf"]> : T extends null | boolean | number | string | Controls["AllowExtensionOf"] ? T : IfExactTypeInUnion<T, Controls["AllowExactly"], true, "not found"> extends true ? T : T extends object ? ExtractFunctionFromIntersection<T> extends {
        classification: "exactly Function";
    } ? never : T extends readonly (infer _)[] ? {
        [K in keyof T]: JsonForDeserializedArrayItem<T[K], Controls, JsonDeserializedRecursion<T[K], Controls, RecurseLimit, TAncestorTypes>>;
    } : IsExactlyObject<T> extends true ? NonNullJsonObjectWith<Controls["AllowExactly"] | Controls["AllowExtensionOf"]> : IsEnumLike<T> extends true ? T : FlattenIntersection<{
        [K in keyof T as NonSymbolWithDeserializablePropertyOf<T, Controls["AllowExactly"], Controls["AllowExtensionOf"], K>]: JsonDeserializedRecursion<T[K], Controls, RecurseLimit, TAncestorTypes>;
    } & {
        [K in keyof T as NonSymbolWithPossiblyDeserializablePropertyOf<T, Controls["AllowExactly"], Controls["AllowExtensionOf"], K>]?: JsonDeserializedRecursion<T[K], Controls, RecurseLimit, TAncestorTypes>;
    }> : never;
    export type JsonDeserializedImpl<T, Options extends Partial<FilterControls>, RecurseLimit extends RecursionLimit = "++++"> = {
        AllowExactly: Options extends {
            AllowExactly: unknown;
        } ? Options["AllowExactly"] : never;
        AllowExtensionOf: Options extends {
            AllowExtensionOf: unknown;
        } ? Options["AllowExtensionOf"] : never;
    } extends infer Controls ? Controls extends FilterControls ? boolean extends (T extends never ? true : false) ? JsonTypeWith<Controls["AllowExactly"] | Controls["AllowExtensionOf"]> : ReplaceRecursionWithMarkerAndPreserveAllowances<T, RecursionMarker, Controls> extends infer TNoRecursionAndOnlyPublics ? IsSameType<TNoRecursionAndOnlyPublics, JsonDeserializedFilter<TNoRecursionAndOnlyPublics, {
        AllowExactly: Controls["AllowExactly"] | RecursionMarker;
        AllowExtensionOf: Controls["AllowExtensionOf"];
    }, 0>> extends true ? HasNonPublicProperties<T, Controls> extends true ? JsonDeserializedFilter<T, Controls, RecurseLimit> : T : JsonDeserializedFilter<T, Controls, RecurseLimit> : never : never : never;
    export type JsonDeserializedRecursion<T, Controls extends FilterControls, RecurseLimit extends RecursionLimit, TAncestorTypes> = T extends TAncestorTypes ? RecurseLimit extends `+${infer RecursionRemainder}` ? JsonDeserializedImpl<T, Controls, RecursionRemainder extends RecursionLimit ? RecursionRemainder : 0> : JsonTypeWith<Controls["AllowExactly"] | Controls["AllowExtensionOf"]> : JsonDeserializedFilter<T, Controls, RecurseLimit, TAncestorTypes | T>;
    export type JsonForDeserializedArrayItem<T, Controls extends FilterControls, TBlessed> = boolean extends (T extends never ? true : false) ? TBlessed : unknown extends T ? TBlessed : T extends null | boolean | number | string | Controls["AllowExtensionOf"] ? T : IfExactTypeInUnion<T, Controls["AllowExactly"], T, T extends undefined | symbol ? null : T extends Function ? ExtractFunctionFromIntersection<T> extends {
        classification: "exactly Function";
    } ? null : null | TBlessed : TBlessed>;
    export type JsonForSerializableArrayItem<T, Controls extends FilterControls, TAncestorTypes extends unknown[], TBlessed> = boolean extends (T extends never ? true : false) ? TBlessed : unknown extends T ? TBlessed : IfExactTypeInTuple<T, TAncestorTypes, T, T extends null | boolean | number | string | Controls["AllowExtensionOf"] ? T : IfExactTypeInUnion<T, Controls["AllowExactly"], T, undefined extends T ? SerializationErrorPerUndefinedArrayElement : TBlessed>>;
    export type JsonSerializableFilter<T, Controls extends FilterControls, TAncestorTypes extends unknown[], TNextAncestor = T> = boolean extends (T extends never ? true : false) ? JsonTypeWith<Controls["AllowExactly"] | Controls["AllowExtensionOf"]> : unknown extends T ? JsonTypeWith<Controls["AllowExactly"] | Controls["AllowExtensionOf"]> : IfExactTypeInTuple<T, TAncestorTypes, true, "no match"> extends true ? T : T extends null | boolean | number | string | Controls["AllowExtensionOf"] ? T : IfExactTypeInUnion<T, Controls["AllowExactly"], true, "no match"> extends true ? T : Extract<T, Function> extends never ? T extends object ? T extends readonly (infer _)[] ? {
        [K in keyof T]: JsonForSerializableArrayItem<T[K], Controls, TAncestorTypes, JsonSerializableFilter<T[K], Controls, [
        TNextAncestor,
        ...TAncestorTypes
        ]>>;
    } : IsExactlyObject<T> extends true ? NonNullJsonObjectWith<Controls["AllowExactly"] | Controls["AllowExtensionOf"]> : IsEnumLike<T> extends true ? T : FlattenIntersection<{
        [K in keyof T as RequiredNonSymbolKeysOf<T, K>]-?: undefined extends T[K] ? {
            ["error required property may not allow undefined value"]: never;
        } : JsonSerializableFilter<T[K], Controls, [
        TNextAncestor,
        ...TAncestorTypes
        ]>;
    } & {
        [K in keyof T as OptionalNonSymbolKeysOf<T, K>]?: JsonSerializableFilter<T[K], Controls, [
        TNextAncestor,
        ...TAncestorTypes
        ]>;
    } & {
        [K in keyof T & symbol]: never;
    }> : never : never;
    export type JsonSerializableImpl<T, Options extends Partial<FilterControls> & {
        IgnoreInaccessibleMembers?: "ignore-inaccessible-members";
    }, TAncestorTypes extends unknown[] = [], TNextAncestor = T> = {
        AllowExactly: Options extends {
            AllowExactly: unknown;
        } ? Options["AllowExactly"] : never;
        AllowExtensionOf: Options extends {
            AllowExtensionOf: unknown;
        } ? Options["AllowExtensionOf"] : never;
    } extends infer Controls ? Controls extends FilterControls ? boolean extends (T extends never ? true : false) ? JsonTypeWith<Controls["AllowExactly"] | Controls["AllowExtensionOf"]> : Options["IgnoreInaccessibleMembers"] extends "ignore-inaccessible-members" ? JsonSerializableFilter<T, Controls, TAncestorTypes, TNextAncestor> : HasNonPublicProperties<T, Controls> extends true ? T extends readonly (infer _)[] ? {
        [K in keyof T]: JsonSerializableImpl<T[K], Controls, [
        TNextAncestor,
        ...TAncestorTypes
        ]>;
    } : SerializationErrorPerNonPublicProperties : JsonSerializableFilter<T, Controls, TAncestorTypes, TNextAncestor> : never : never;
    export type NonSymbolWithDeserializablePropertyOf<T extends object, TExactException, TExtendsException, Keys extends keyof T = keyof T> = Exclude<{
        [K in Keys]: ExcludeExactly<Exclude<T[K], TExtendsException>, TExactException> extends infer PossibleTypeLessAllowed ? Extract<PossibleTypeLessAllowed, undefined | symbol | Function> extends never ? IfSameType<PossibleTypeLessAllowed, bigint, never, T[K] extends never ? never : K> : never : never;
    }[Keys], undefined | symbol>;
    export type NonSymbolWithPossiblyDeserializablePropertyOf<T extends object, TExactException, TExtendsException, Keys extends keyof T = keyof T> = Exclude<{
        [K in Keys]: Extract<ExcludeExactly<Exclude<T[K], TExtendsException>, TExactException>, undefined | symbol | Function> extends never ? never : TestDeserializabilityOf<T[K], TExactException, TExtendsException, {
            WhenSomethingDeserializable: K;
            WhenNeverDeserializable: never;
        }>;
    }[Keys], undefined | symbol>;
    export type OptionalNonSymbolKeysOf<T extends object, Keys extends keyof T = keyof T> = Exclude<{
        [K in Keys]: T extends Record<K, T[K]> ? never : K;
    }[Keys], undefined | symbol>;
    export type RecursionLimit = `+${string}` | 0;
    export interface RecursionMarker {
        // (undocumented)
        [RecursionMarkerSymbol]: typeof RecursionMarkerSymbol;
    }
    export type ReplaceAllowancesAndRecursionWithNever<T, Controls extends FilterControls, TAncestorTypes extends unknown[] = [], TNextAncestor = T> = IfExactTypeInTuple<T, TAncestorTypes, true, "no match"> extends true ? never : T extends Controls["AllowExtensionOf"] ? never : IfExactTypeInUnion<T, Controls["AllowExactly"], true, "no match"> extends true ? never : T extends object ? FilterPreservingFunction<T, {
        [K in keyof T]: ReplaceAllowancesAndRecursionWithNever<T[K], Controls, [
        TNextAncestor,
        ...TAncestorTypes
        ]>;
    }> : T;
    export type ReplaceRecursionWithMarkerAndPreserveAllowances<T, TRecursionMarker, Controls extends FilterControls, TAncestorTypes extends unknown[] = [], TNextAncestor = T> = IfExactTypeInTuple<T, TAncestorTypes, true, "no match"> extends true ? TRecursionMarker : T extends Controls["AllowExtensionOf"] ? T : IfExactTypeInUnion<T, Controls["AllowExactly"], true, "no match"> extends true ? T : T extends object ? FilterPreservingFunction<T, {
        [K in keyof T]: ReplaceRecursionWithMarkerAndPreserveAllowances<T[K], TRecursionMarker, Controls, [
        TNextAncestor,
        ...TAncestorTypes
        ]>;
    }> : T;
    export type RequiredNonSymbolKeysOf<T extends object, Keys extends keyof T = keyof T> = Exclude<{
        [K in Keys]: T extends Record<K, T[K]> ? K : never;
    }[Keys], undefined | symbol>;
    export type TestDeserializabilityOf<T, TExactException, TExtendsException, Result extends {
        WhenSomethingDeserializable: unknown;
        WhenNeverDeserializable: never;
    } | {
        WhenSomethingDeserializable: never;
        WhenNeverDeserializable: unknown;
    }> = T extends never ? Result["WhenNeverDeserializable"] : T extends TExtendsException ? Result["WhenSomethingDeserializable"] : IfExactTypeInUnion<T, TExactException, Result["WhenSomethingDeserializable"], T extends bigint | symbol | undefined ? Result["WhenNeverDeserializable"] : T extends Function ? ExtractFunctionFromIntersection<T> extends {
        classification: "exactly Function";
    } ? Result["WhenNeverDeserializable"] : Result["WhenSomethingDeserializable"] : Result["WhenSomethingDeserializable"]>;
}

// @public (undocumented)
export interface IProvideFluidLoadable {
    // (undocumented)
    readonly IFluidLoadable: IFluidLoadable;
}

// @public (undocumented)
export interface IRequest {
    // (undocumented)
    headers?: IRequestHeader;
    // (undocumented)
    url: string;
}

// @public (undocumented)
export interface IRequestHeader {
    // (undocumented)
    [index: string]: any;
}

// @public (undocumented)
export interface IResponse {
    // (undocumented)
    headers?: {
        [key: string]: any;
    };
    // (undocumented)
    mimeType: string;
    // (undocumented)
    stack?: string;
    // (undocumented)
    status: number;
    // (undocumented)
    value: any;
}

// @public
export interface ITelemetryBaseEvent extends ITelemetryBaseProperties {
    // (undocumented)
    category: string;
    // (undocumented)
    eventName: string;
}

// @public
export interface ITelemetryBaseLogger {
    minLogLevel?: LogLevel;
    send(event: ITelemetryBaseEvent, logLevel?: LogLevel): void;
}

// @public
export interface ITelemetryBaseProperties {
    [index: string]: TelemetryBaseEventPropertyType | Tagged<TelemetryBaseEventPropertyType>;
}

// @beta
export type JsonDeserialized<T, Options extends JsonDeserializedOptions = {
    AllowExactly: never;
    AllowExtensionOf: never;
}> = InternalUtilityTypes.JsonDeserializedImpl<T, Options>;

// @beta
export interface JsonDeserializedOptions {
    AllowExactly?: unknown;
    AllowExtensionOf?: unknown;
}

// @beta
export type JsonSerializable<T, Options extends JsonSerializableOptions = {
    AllowExactly: never;
    AllowExtensionOf: never;
}> = InternalUtilityTypes.JsonSerializableImpl<T, Options>;

// @beta
export interface JsonSerializableOptions {
    AllowExactly?: unknown;
    AllowExtensionOf?: unknown;
    IgnoreInaccessibleMembers?: "ignore-inaccessible-members";
}

// @beta
export type JsonTypeWith<T> = null | boolean | number | string | T | {
    [key: string | number]: JsonTypeWith<T>;
} | JsonTypeWith<T>[];

// @public
export const LogLevel: {
    readonly verbose: 10;
    readonly default: 20;
    readonly error: 30;
};

// @public
export type LogLevel = (typeof LogLevel)[keyof typeof LogLevel];

// @beta
export type NonNullJsonObjectWith<T> = {
    [key: string | number]: JsonTypeWith<T>;
} | JsonTypeWith<T>[];

// @public
export type ReplaceIEventThisPlaceHolder<L extends any[], TThis> = L extends any[] ? {
    [K in keyof L]: L[K] extends IEventThisPlaceHolder ? TThis : L[K];
} : L;

// @beta
export type SerializationErrorPerNonPublicProperties = {
    "object serialization error": "non-public properties are not supported";
};

// @beta
export type SerializationErrorPerUndefinedArrayElement = {
    "array serialization error": "undefined elements are not supported";
};

// @public
export interface Tagged<V, T extends string = string> {
    // (undocumented)
    tag: T;
    // (undocumented)
    value: V;
}

// @public
export type TelemetryBaseEventPropertyType = string | number | boolean | undefined;

// @public
export type TransformedEvent<TThis, E, A extends any[]> = (event: E, listener: (...args: ReplaceIEventThisPlaceHolder<A, TThis>) => void) => TThis;

// (No @packageDocumentation comment for this package)

```
